# C++基础

## C++的产生和特点

​	C++ 是在 C 语言的基础上发展起来的。C 语言呢，很厉害，但是随着软件需求越来越复杂，人们就觉得 C 语言有些地方不够用啦。于是呢，丹麦的计算机科学家比雅尼・斯特劳斯特鲁普就开始琢磨怎么改进 C 语言。他就创造了 C++，让编程变得更强大、更灵活。

​	下面用一个超简单的 C++ 代码来感受一下。

```cpp
#include <iostream>
int main() {
    std::cout << "Hello, C++!" << std::endl;
    return 0;
}
```

##  C++在非面向对象方面对C语言的扩充

### 输入输出

```cpp
#include<iostream>
//cin cout 从内存中输入输出 分别是 istream类型 ostream类型
//cin是istream类型的对象，cout是ostream类型的对象
//c++的头文件库包含c语言的头文件库 可以写scanf和printf
using namespace std;
//namespace命名空间 std-标准
//使用标准命名空间 限制cin/cout的使用范围在std下
namespace S
{
	int a;
}
int a, b;//全局
int main()
{
    //cin 从控制台读入内容到变量。 cout从变量输出内容到控制台。
	cin >>a >> b;
	cout << a <<" " << b<<endl;//endl--换行
	S::a = 4;//S是作用域
	cout << a << " " << b << endl;
	cout << S::a << " " << b << endl;
	return 0;
}
```

### 内联函数

​	在函数名前冠以关键字`inline`，该函数就被声明为**内联函数**。内联函数其实就是一种让编译器在调用时把函数的代码直接插入到调用处的方法，而不是像普通函数那样在运行时去跳转到函数的地址执行。这么做的好处是可以减少一些函数调用的开销，比如省掉了压栈、出栈这些步骤。对一些简单、频繁调用的函数来说，用内联能提高程序的执行效率。不过也有缺点，就是如果函数体积比较大，频繁展开的话，可能会导致代码体积变大，从而占用更多的内存。另外，编译器不一定会把你标记为内联的函数都展开，它会根据实际情况来决定。

​	比如说，你有个小函数，就像下面这个：

```cpp
inline int addTwoNumbers(int a, int b) {
    return a + b;
}
```

​	这里的`inline`关键字就 告诉 编译器把这个函数当成内联函数。这样当你在程序里调用这个函数的时候，比如：

```cpp
int main() {
    int result = addTwoNumbers(3, 4);
    std::cout << "Result: " << result << std::endl;
    return 0;
}
```

​	编译器可能就直接把`addTwoNumbers(3, 4)`替换成`3 + 4`，这样就省了函数调用的开销，程序执行起来就会更快一些。但是呢，也不是啥函数都适合定义成内联函数哦。如果函数特别复杂，代码很长，那定义成内联函数可能反而不好，因为会让编译后的程序变得很大。一般来说，那些短小又经常被调用的函数比较适合定义成内联函数。

### 带有默认参数值的函数

​	当进行函数调用时，编译器按从左到右的顺序将实参与形参结合，若未指定足够的实参，则编译器按顺序用函数原型中的默认值来补足所缺少的实参。

```c++
void init(int x = 5, int y = 10);
init (100, 19);   // 100 ， 19
init(25);         // 25, 10
init();           // 5， 10
```

​	在函数原型中，所有取默认值的参数都必须出现在不取默认值的参数的右边。

​	如 `int fun(int a, int b, int c = 111);`在函数调用时，若某个参数省略，则其后的参数皆应省略而采取默认值。不允许某个参数省略后，再给其后的参数指定参数值。

### 函数重载

​	函数重载呢，就是在同一个作用域里，可以有多个同名的函数。听起来有点奇怪，肯定有这样的疑问为啥要多个同名函数呢？这是因为这些同名函数虽然名字一样，但是它们的参数不一样。函数在调用时，是在编译期间确定调用哪个重载函数的 ，根据实参类型确定的。编译器会选择一个最合适的函数来执行。

​	面试中常会出现的是常成员函数和非常成员函数互为重载（** 规则：常对象(实例化时必须用const进行修饰)调用 常成员函数， 普通对象调用 普通成员函数**）**

​	比如说，你可能有一个求两个整数相加的函数：

```cpp
int add(int a, int b) {
    return a + b;
}
```

​	然后呢，你又想有一个求三个整数相加的函数，这时候你不用再起个新名字，直接可以再写一个函数：

```cpp
int add(int a, int b, int c) {
    return a + b + c;
}
```

​	这样，当你在程序里调用`add`函数的时候，编译器会根据你传进去的参数个数和类型来决定调用哪个具体的函数。如果传两个整数，就调用两个参数的那个`add`函数；如果传三个整数，就调用三个参数的那个。

​	由此可以得到函数重载的特点，他让你的代码更简洁、更易读。不用为了类似但参数不同的功能去想一堆不同的函数名，直接用一个名字，根据不同的需求来调用不同版本的函数就行。

这里有有一个常见的面试题：

#### **C语言为什么不能重载而C++可以？**

​	原因就是C语言和c++的编译方式不同，c++中编译器编译后函数名是由原函数名+参数类型构成 ，参数不同就是函数名不同，调用时不会发生冲突，而C语言编译方式起完的名字还是自己 如果重载会发生重定义错误。

### bool类型

​	在 C++ 中，bool 类型就是专门用来表示真假的。它只有两个值，一个是 true，表示真；另一个是 false，表示假。

bool类型特点是：

- bool类型 :是c++中一种整型类型   只占1字节 值仅有两个  false(0)和true(1)

- 非零的正负数都是1(false)

  比如说，你可以这样用：

  ```cpp
  #include<iostream>
  using namespace std;
  
  int main()
  {
  	bool a1 = -1 ;    //将被转换为true，非零正负值都转换为true。
  	bool a2 = 0;      //将被转换为false
  	int b1 = true;    //将被转换为1
  	int b2 = false;   //将被转换为0
  	
      cout << a1 << endl;
  	cout << a2 << endl;
  	cout << b1 << endl;
  	cout << b2 << endl;
  return 0;
  }
  ```

  下面这是一道常见面试题：

##### **bool类型为什么只占一个字节？**   

​	首先呢，bool 类型在 C++ 里主要是用来表示真（true）和假（false）这两种状态。它不需要像其他数据类型那样存储很大范围的值。

​	从存储空间的角度来看，一个字节通常有 8 个位（bit）。对于只需要表示两种状态的 bool 类型来说，理论上只需要一个位就够了，0 可以表示 false，1 可以表示 true。但是在实际的计算机系统中，由于内存对齐和寻址等方面的考虑，通常会把 bool 类型分配一个字节的空间。

### new操作符

- 是C++中在堆区开辟数据的

- 语法：new+数据类型 

- 利用new创建的数据会返回数据对应类型的指针

- 在堆区申请内存，释放时用delete 释放数组是用delete[]

- new申请数组时返回首元素的地址，申请int型变量返回的是这块地址

  下面用一个简单的代码来感受一下。

```cpp
int main()
{
	int* a1 = new int;//在堆区申请一块内存为int类型的内存 随机值
	cout << a1 << endl;
	delete a1;

	int* a2 = new int();//在堆区申请一块内存为int类型的内存 值为0
	cout << a2 << endl;
	delete a2;

	int* a3 = new int(4);//在堆区申请一块内存为int类型的内存 4
	cout << a3 << endl;
	delete a3;

	int* a4 = new int [3];
	for (int i = 0; i <3; i++) 
        cout << a4[i]<<" ";//在堆区申请一块内存为int类型的数组 值随机值
	delete[]a4;//释放时不加[]会发生 内存泄漏（这块内存丢了，找不到）

	int* a5 = new int[3] {1, 2, 3};//在堆区申请int类型数组 值为1 2 3
	cout << a5;
	delete[]a5;
    cout<<a5;//报错，释放的空间无法找到并访问
	return 0;
}
#include<iostream>
using namespace std;

int* fun()
{
	int* p = new int(3);
	return 0;
}
int main()
{
    //p指向堆区，然后给了q指向堆区内存，p消失的原因--栈区内存编译器自动管理
	int* q = fun();
	delete q;//不delete会导致内存泄漏
	return 0;
}
//delete数组不加[]也会发生内存泄漏
#include<iostream>
using namespace std;

int* fun()
{
	int* p = new int(3);
	return 0;
}
int main()
{
	fun();//会发生内存泄漏，找不到这块地址了
	return 0;
}
```

#### **new和malloc的区别**

​	new是在堆区申请内存的，如果给类或者结构体申请内存的话会优先调用malloc 再调用构造函数，释放new申请的内存需要使用delete,释放数组需要delete[],delete会先调用析构函数在调用free,当这个类的析构函数没有作用时，也可以使用free释放new申请的堆区空间。

具体区别在以下几个方面来讲：

- 1.返回值 new返回值不需要强转 而malloc返回值需要强转。
- 2.名字：new是运算符可以重载而 malloc是c语言库函数不可以重载。
- 3.参数：new不需要传入具体字节个数 而malloc需要。
- 4.函数体：new先调用malloc再调用构造函数给成员变量赋值 delete先调用析构在调用free，malloc只分配堆区内存。
- 5.申请内存失败：new会抛出异常而 malloc返回空。

#### **malloc分配内存失败的情况：**

(1) 参数不正确

```cpp
int*p =(int *)malloc(-12);//不能为负数
```

(2) 堆区没足够的空间

### 引用

​	在 C++ 中，引用就像是一个变量的别名。它让你可以给一个已经存在的变量起另外一个名字，通过这个别名来操作原来的变量。比如说，你有一个整数变量 `int num = 10;`，然后你可以创建一个引用 `int& ref = num;`。现在 `ref` 就是 `num` 的引用，你对 `ref` 进行操作就相当于对 `num` 进行操作。比如 `ref = 20;`，这时 `num` 的值也会变成 20。

引用有几个重要的特点呢。

​	首先，引用必须在创建的时候就初始化，不能像普通变量那样先声明后赋值。一旦引用被初始化指向一个变量，就不能再指向其他变量了。

​	其次，引用不是一个独立的变量，它只是原变量的一个别名，所以它不占用额外的内存空间。

#### **引用的划分**

- 左值：有名字的变量，能找到地址的变量，能修改的
- 右值：找不到地址，没名字的，不能修改的 函数返回值
- 左值引用：只能接收左值   int a;int &b=a; 右值引用是左值
- 右值引用：只能接收右值    int&&c=2;   常量 匿名对象 
- 万能引用：在左值引用前加const int a=1;const int &b=1;const int&c=a;既可以接受左值也可以接受右值

#### **引用的用处:**

​	用在函数的参数位置,使用引用传承,避免拷贝,减少内存开销,可以替代指针增加代码的可读性和安全性(因为避免了nullptr),可以直接修改参数的值用在函数的返回值避免拷贝构造,如果返回值类型是引用,那么这时候返回值就不会进行拷贝直接返回的是变量的地址。

#### **引用和指针的区别?**

- 引用必须初始化,指针不是必须的
- 引用不能为空,指针可以为空
- 引用没有多级引用,指针有多级指针
- 如果对引用sizeof()得到的是引用的对象的大小 如果对指针sizeof得到是指针本身的大小也就是4或8
- 引用比指针更安全,(指针有野指针,悬挂指针,访问空指针)
- 引用不能改变指向但是指针可以改变指向
- 引用比指针用起来更方便
- 指针作为函数传参时传递的是指针变量的值,而引用作为函数参数传递时传递的是实参本身

​	下面这个例代码进一步了解引用：

```cpp
void increment(int& value) {
    value++;
}

int main() {
    int num = 10;
    increment(num);
    std::cout << "num after increment: " << num << std::endl;
    return 0;
}
```

​	在这个例子中，函数 `increment` 通过引用参数修改了传入的变量，所以在 `main` 函数中，`num` 的值被成功地增加了。

​	此外，正常一个函数的返回值为右值，如果想返回左值的话要以引用的方式  int & dun(){};

```cpp
#include<iostream>
using namespace std;

int & fun()
{
	int a = 10;
	return a;
}
int main()
{
	int& aaa = fun();
	cout << aaa << endl;//正常会输出随机值，因为函数结束a被释放掉
    //会输出10的原因：未来得及将a释放掉编译器先输出了
	cout << aaa << endl;//随机值
	return 0;
}
```

引入一个新概念**匿名对象**（是一个右值）它的特点如下：

- 没有名字的对象
- 只存在于当前行，到下一行就被释放掉了
- 函数以引用方式返回的值是左值    不引用返回的是匿名对象

拷贝构造参数传引用的时候我想大家一定有一个问题那就是为什么要用const修饰形参，是防止形参改变实参，而传引用是为了避免无限递归。

### **参数传递的两种方式**

#### 值传递

​	值传递就是把实际参数的值复制一份传递给函数的形式参数。这就相当于在函数内部创建了一个新的变量，这个变量的值和实参一样，但是它们是两个独立的变量，修改函数内部的这个变量不会影响到外部的实参。

比如：

```cpp
void incrementValue(int num) {
    num++;
}

int main() {
    int value = 10;
    incrementValue(value);
    std::cout << "Value after function call: " << value << std::endl;
    return 0;
}
```

在这个例子中，`incrementValue`函数接收一个整数参数，在函数内部将这个参数的值加一。但是在 `main` 函数中，输出的 `value` 的值仍然是 10，没有被修改。这是因为在函数调用时，只是把 `value` 的值复制了一份传递给了函数，函数内部操作的是这个副本，而不是原始的 `value`。

#### **引用传递**

​	引用传递是把实际参数的引用（也就是别名）传递给函数的形式参数。这样在函数内部对形式参数的操作实际上就是对外部实参的操作，因为它们指向的是同一个内存地址。

比如：

```cpp
void incrementReference(int& num) {
    num++;
}

int main() {
    int value = 10;
    incrementReference(value);
    std::cout << "Value after function call: " << value << std::endl;
    return 0;
}
```

​	在这个例子中，`incrementReference`函数接收一个整数的引用作为参数。在函数内部将这个引用所指向的变量的值加一。在 `main` 函数中，输出的 `value` 的值变成了 11，因为在函数调用时，传递的是 `value` 的引用，函数内部对这个引用的操作直接影响到了外部的 `value`。

​	总的来说，值传递适用于不需要修改原始数据或者需要保护原始数据不被修改的情况；引用传递适用于需要在函数内部修改原始数据或者希望避免复制大型数据结构带来的开销的情况。

