# MySQL
## 基础知识

>    执行一个select语句都发生了什么?
>

### 首先一个语句的执行分为两层

​	server层:建立连接,分析并执行sql

具体有 连接器 查询缓存 解析器 预处理器 优化器 执行器

​    存储引擎层:数据的存储和执行

#### **连接器:**

```mysql
mysql -h$ip -u$user -p$password
##   ip指的是你要连接的服务器所在ip
##   user 指的是用户名,管理员角色为 root
##    -p 是密码
查看数据库的连接情况
## 数据库中输入
show processlist
```

![](../photo/mysql/1.png)

command(命令) 指的是用户当前命令状态 sleep指的是连接完就没有执行命令

query 刚查询过  后面的time 是空闲时间 6号用户已经空闲了736秒  

空闲连接不会一直占用 mysql定义了最大空闲时间,由wait_timeout参数控制默认值是8小时

超出了这个世界连接器就会自动将它断开.

也可以自己断开连接

```cpp
kill connection +x;     //x是id
```

连接限制  用 max_connections 关键字表示 默认的是151 超过这个值就拒绝接下来的连接请求

并报错提示 too many connections

mysql 也和http一样有长短连接的概念区别如下

```cpp
//短连接
连接mysql服务器  tcp三次握手
执行sql
断开tcp四次挥手

//长连接
连接mysql服务器  tcp三次握手
执行sql
...
执行sql
断开tcp四次挥手
```

但是使用长连接可能会导致占用内存增多，因为MySQL在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开的时候才会释放。如果长连接累计很多，将导致MySQL服务占用内存太大，有可能会被系统强制杀掉，这样就会发生MySQL服务器异常重启现象。

怎样解决长连接占用内存的问题呢？

1.定期断开长连接

2.客户端主动断开连接   客户端在执行完了一个很大的操作后在代码里调用 mysql_reset_connection函数来重置链接，达到释放内存的效果，将链接状态恢复到刚刚创建完成时的状态。

#### 查询缓存

查询缓存就是 接受的一条指令之后先去查询缓存看一下,如果有就直接返回,它保存的形式是key -value  key是语句 value 是结果

如果查询缓存没有就去数据库查一下返回并把这个语句和结果存key -value

但是查询缓存命中率太低了,只要表一修改所有的查询缓存就会被清理掉

有点鸡肋所以8.0之后就直接删除了

#### 解析器

解析器只负责检查语法和构建语法树

预处理

检查sql查询语句中的表或者字段是否存在（其他博主扒源码发现的）

将select中的*扩展为表上的所有列

#### 优化器

优化器主要负责将sql查询语句的执行方案确定下来，比如选择使用什么索引

要想知道一条语句使用了什么索引只需要在语句前加上expain命令，结果里面的key字段就是使用了哪个索引

#### 执行器

执行sql语句

### 一行数据是如何被存储的