创建进程的方式：

系统初始化：启动操作系统时会创建若干个进程

用户请求创建：例如双击图标启动程序

系统调用创建：一个运行的进程可以发出系统调用创建新的进程帮助其完成工作

**fork()函数：**创建进程，新创建的是当前进程的子进程

成功 父进程返回新创建的子进程ID ，子进程返回0

失败返回-1，子进程不被创建

子进程的代码是当前父类的代码复制了一份给子进程

![](https://cdn.nlark.com/yuque/0/2024/png/40599201/1716290307936-2c36631f-00b9-4da5-a981-c4a6205b9e27.png)

while(1)作用：死循环，保证两个进程都不结束

```c
int pid = fork();
	if(pid == 0){
    //获取当前id和父进程id
	printf("child,pid = %d,ppid= % d\n",getpid(),getppid());
	}
	else{
		printf("parent,pid = %d,ppid = %d\n",getpid(),getppid());
	}
```

命令查看进程

```c
ps -ef | grep ./main
```

子进程和父进程的局部变量和堆区都不会共享，因为每一个进程会单独分配一块内存。(虚拟地址)



创建进程时不能循环创建，只让父进程创建不让子进程创建。

进程的状态：阻塞，就绪，运行。

运行的进程遇到阻塞事件会变成阻塞态，阻塞事件结束变成就绪态，当进程调度程序选择到这个程序变回运行态。分配给这个程序的时间片用没了会变成就绪态。

结束进程：程序正常退出，主函数return 0 或者 系统调用exit

                 异常退出，信号杀死  q,-9强制杀死

### exit
exit（）是库函数，系统调用是exit(1),一般用库函数,参数是退出状态

exit(0)是正常退出 非0是异常退出.保存在全局变量$?中，$?保存的是最近一次运行的进程的返回值

![](https://cdn.nlark.com/yuque/0/2024/png/40599201/1716465194378-34c649c6-b275-488a-ac73-caee9cca271a.png)

当子进程结束时，要由父进程进行回收，子进程结束产生的残留资源由父进程回收，只有父进程结束时候才会回收子进程。1号进程负责回收进程

最开始是有0号进程，0号进程产生1号和2号进程

kill -9 101180

16dd删除16行



### 孤儿进程
![](https://cdn.nlark.com/yuque/0/2024/png/40599201/1716465883605-06955075-9325-430f-9a6f-32707fc879c6.png)



孤儿进程和僵尸进程：一个进程结束，父子进程一定有一个先结束。父进程先结束的子进程是孤儿进程，结束后不会立刻回收，会被1号进程领养。子进程先结束是僵尸进程，便能够直接杀死，要杀死父进程才能回收。



wait函数：

![](https://cdn.nlark.com/yuque/0/2024/png/40599201/1716466370653-5d02c0e6-8923-4bce-88c9-8eddb57270aa.png) 





创建进程的目的?

exec 在一个程序中调用另一个程序









