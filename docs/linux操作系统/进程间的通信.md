进程间通信就是在不同进程间传播或交换信息。

### 管道
ls | wc -l:当前目录下的文件数

两个文件描述符，是为了互不影响

匿名管道：适用于父子进程间，或者有血缘关系间

管道符是阻塞文件（阻塞--读不到数据是会一直等着，直到得到结果）

#### pipe--创建匿名管道
参数是传出参数，

匿名管道用于进程间的通信，<font style="color:#DF2A3F;">仅限于本地关联进程间的通信。</font>

匿名指的是文件名

读写规则：

+ 管道中没数据：write返回成功写入的字节数，读端进程阻塞在read上
+ 管道中数据没满：write返回成功写入的字节数，read返回读取的字节数
+ 管道已满：写端进程阻塞在write上，read返回读取的字节数
+ 写端全部关闭：read正常读取，返回的读到的字节数（没有数据时返回0不阻塞）
+ 读端全部关闭：写端进程write入会异常终止（被信号SIGPIPE终止）



管道文件会等着写入后才去读

命名管道：

### mkfifo（）--创建命名管道
+ 头文件：#include<sys/stat.h>
+ mkfifo（要创建的命名管道文件，给这个管道的默认权限）
+ 成功返回0，失败返回-1

写进程会等读进程，读进程也会等写进程。

命名管道的打开规则规则：

读进程打开命名管道，没有写进程打开：

没有O_NONBLOCK：处于阻塞状态，直到有写进程打开时，打开该命名管道。

没有O_NONBLOCK：立刻返回成功。

写进程打开命名管道，没有读进程打开：

没有O_NONBLOCK：处于阻塞状态，直到有读进程打开时，打开该命名管道。

有O_NONBLOCK：立刻返回失败，错误码为ENXIO。

管道文件是一个内存文件，不是磁盘文件。

ls查看的是磁盘中占的大小。





使用fifo写一个简单的聊天程序。两个终端，一面发另一面接收，一直能发消息，你发时候他也能发，互不影响。不能实现互相发，可以先试下单向发。

1.死消息变活消息

2.发多条消息

3.互相发



mmap返回的是指针指向内存的起始位置。

为什么有进程

为什么需要回收

为什么要创建进程？

多个任务同时执行，执行大人物时候需要并行（串行很慢）。

问什么要有多进程？

进程为什么要回收？一个进程的结束会有残留资源，回收资源节省空间。







































